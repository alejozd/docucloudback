const fs = require("fs");
const path = require("path");
const mm = require("music-metadata");

// Define la ruta base donde se guardarán los videos
const VIDEO_BASE_DIR = "/var/www/videos";
// const VIDEO_BASE_DIR = "C:/Users/Alejandro Zambrano/Documents/Alejo"; // Tu ruta de desarrollo

// =========================================================
// FUNCIÓN PESADA: Escanea disco y extrae metadatos
// Esta función SÓLO se llama una vez al inicio del servidor (desde index.js)
// =========================================================
async function scanAndProcessVideos() {
  const promises = []; // Array para guardar todas las promesas de lectura de metadatos

  // Función recursiva para recorrer directorios
  const readDirectory = async (currentPath, relativePath = "") => {
    const items = fs.readdirSync(currentPath);

    for (const item of items) {
      const itemPath = path.join(currentPath, item);
      const itemRelativePath = path.join(relativePath, item);
      const stats = fs.statSync(itemPath);

      if (stats.isDirectory()) {
        await readDirectory(itemPath, itemRelativePath);
      } else if (stats.isFile() && item.endsWith(".mp4")) {
        // Obtenemos el nombre de la carpeta (categoría)
        const parts = itemRelativePath.split(path.sep);
        const carpeta = parts.length > 1 ? parts[0] : "Sin Categoría";
        const url = `/videos/${itemRelativePath.replace(/\\/g, "/")}`; // URL para el frontend

        // Agregamos una función que devuelve una promesa (lectura de metadatos) al array
        promises.push(
          (async () => {
            let titulo = item.replace(".mp4", "");
            let artista = "Desconocido";
            let año = null;
            let genero = "Desconocido";
            let duracion_segundos = 0;

            try {
              // Lectura intensiva de metadatos
              const metadata = await mm.parseFile(itemPath);

              titulo = metadata.common.title || titulo;
              artista =
                metadata.common.artist ||
                metadata.common.albumartist ||
                artista;
              año = metadata.common.year || año;
              genero =
                metadata.common.genre && metadata.common.genre.length > 0
                  ? metadata.common.genre[0]
                  : genero;
              if (metadata.format && metadata.format.duration) {
                duracion_segundos = Math.round(metadata.format.duration);
              }
            } catch (metaError) {
              console.warn(
                `[WARN] No se pudieron leer metadatos de ${itemRelativePath}:`,
                metaError.message
              );
            }

            // Devolvemos el objeto de video para Promise.all
            return {
              nombreArchivo: item,
              rutaRelativa: itemRelativePath,
              carpeta: carpeta,
              titulo: titulo,
              artista: artista,
              año: año,
              genero: genero,
              duracion_segundos: duracion_segundos,
              url: url,
            };
          })()
        );
      }
    }
  };

  // 1. Inicia la lectura del directorio y acumula las promesas
  await readDirectory(VIDEO_BASE_DIR);

  // 2. Espera a que TODAS las promesas de lectura de metadatos se resuelvan
  const results = await Promise.all(promises);

  // 3. Devuelve la lista limpia, lista para ser cacheada
  return results.filter((r) => r !== null);
}

// =========================================================
// RUTA HTTP: Lista videos (SÓLO lee de la caché)
// =========================================================
exports.listarVideos = (req, res) => {
  // [CLAVE] Lee de la caché global que se llenó en index.js
  if (!global.videoCache || global.videoCache.length === 0) {
    console.error(
      "La caché de videos está vacía. El servidor no ha inicializado o falló la carga."
    );
    // Devolvemos un 503 (Servicio no disponible) para indicar que la caché está en proceso o falló
    return res.status(503).json({
      error:
        "La lista de videos no está disponible. El servidor está inicializando o ha ocurrido un error.",
    });
  }

  // [CLAVE] Devuelve la lista INSTANTÁNEAMENTE desde la memoria
  return res.json(global.videoCache);
};

// [Exportar la función pesada] Para que index.js pueda llamarla una sola vez
exports.scanAndProcessVideos = scanAndProcessVideos;
