const fs = require("fs");
const path = require("path");
const mm = require("music-metadata"); //

const VIDEO_BASE_DIR = "/var/www/videos"; //

// [MODIFICADO] Función para listar videos y sus metadatos de forma recursiva
exports.listarVideos = async (req, res) => {
  const listaVideos = [];
  const promises = []; // Array para guardar todas las promesas de lectura de metadatos

  try {
    const readDirectory = async (currentPath, relativePath = "") => {
      const items = fs.readdirSync(currentPath); // Mantenemos síncrona la lectura del directorio para simplicidad

      for (const item of items) {
        const itemPath = path.join(currentPath, item); //
        const itemRelativePath = path.join(relativePath, item); //
        const stats = fs.statSync(itemPath);

        if (stats.isDirectory()) {
          await readDirectory(itemPath, itemRelativePath); //
        } else if (stats.isFile() && item.endsWith(".mp4")) {
          // [NUEVO] Agregamos una función que devuelve una promesa (lectura de metadatos) al array de promises
          promises.push(
            (async () => {
              let titulo = item.replace(".mp4", ""); //
              let artista = "Desconocido"; //
              let año = null; //
              let genero = "Desconocido"; //
              let duracion_segundos = 0; //
              let url = `/videos/${itemRelativePath}`; //
              let carpeta = "Sin Categoría"; //

              const relativeParts = relativePath.split(path.sep); //
              if (relativeParts.length > 0 && relativeParts[0] !== "") {
                carpeta = relativeParts[0]; //
              }

              try {
                // [CLAVE] Esta es la operación intensa, pero se ejecuta en paralelo con las demás
                const metadata = await mm.parseFile(itemPath); //
                // ... (Manejo de metadatos) ...
                if (metadata.common) {
                  titulo = metadata.common.title || titulo; //
                  artista =
                    metadata.common.artist ||
                    metadata.common.albumartist ||
                    artista; //
                  año = metadata.common.year || null; //
                  genero =
                    metadata.common.genre && metadata.common.genre.length > 0
                      ? metadata.common.genre[0]
                      : genero; //
                }
                if (metadata.format && metadata.format.duration) {
                  duracion_segundos = Math.round(metadata.format.duration); //
                }
              } catch (metaError) {
                console.warn(
                  `[WARN] No se pudieron leer metadatos de ${itemRelativePath}:`,
                  metaError.message
                ); //
              }

              // Devolvemos el objeto de video para Promise.all
              return {
                nombreArchivo: item, //
                rutaRelativa: itemRelativePath, //
                carpeta: carpeta,
                titulo: titulo,
                artista: artista, //
                año: año, //
                genero: genero, //
                duracion_segundos: duracion_segundos, //
                url: url, //
              };
            })()
          );
        }
      }
    };

    // 1. Inicia la lectura del directorio y acumula las promesas
    await readDirectory(VIDEO_BASE_DIR); //

    // 2. [CLAVE] Espera a que TODAS las promesas de lectura de metadatos se resuelvan en paralelo
    const results = await Promise.all(promises);

    // 3. Filtra cualquier resultado nulo (si manejaste errores dentro de las promesas) y devuelve
    return res.json(results.filter((r) => r !== null));
  } catch (error) {
    // ... (Manejo de errores) ...
    console.error("Error al listar videos:", error); //
    if (error.code === "ENOENT") {
      return res.status(404).json({
        error: `El directorio base de videos no existe: ${VIDEO_BASE_DIR}`,
      }); //
    }
    return res.status(500).json({ error: "No se pudo listar los videos" }); //
  }
};
